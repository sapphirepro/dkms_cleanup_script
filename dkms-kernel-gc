#!/usr/bin/env bash
# dkms-kernel-gc â€” openSUSE Tumbleweed orphan cleanup for DKMS + /usr/lib/modules
set -euo pipefail
IFS=$'\n\t'

# ---------- config ----------
DKMS_ROOT="/var/lib/dkms"
MODULES_ROOT="/usr/lib/modules"
BOOT_ROOT="/boot"

# ---------- helpers ----------
die() { echo "ERROR: $*" >&2; exit 1; }

DRY_RUN=0
QUIET=0

log() {
  (( QUIET )) && return 0
  echo "$@"
}

run_rm_rf() {
  local path="$1"
  if (( DRY_RUN )); then
    log "[dry-run] rm -rf -- '$path'"
  else
    rm -rf -- "$path"
  fi
}

usage() {
  cat <<'EOF'
dkms-kernel-gc (openSUSE Tumbleweed)

Usage:
  dkms-kernel-gc [--dry-run] [--quiet]

Options:
  --dry-run   Print actions, do not delete anything
  --quiet     Less output
EOF
}

# ---------- args ----------
while (( $# )); do
  case "$1" in
    --dry-run) DRY_RUN=1 ;;
    --quiet)   QUIET=1 ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown option: $1" ;;
  esac
  shift
done

# ---------- root escalation ----------
if [[ "${EUID}" -ne 0 ]]; then
  if command -v sudo >/dev/null 2>&1; then
    exec sudo -- "$0" $([[ $DRY_RUN -eq 1 ]] && echo --dry-run) $([[ $QUIET -eq 1 ]] && echo --quiet)
  fi
  die "Must be run as root (or install sudo)."
fi

# ---------- detect modules root ----------
if [[ ! -d "$MODULES_ROOT" ]]; then
  # fallback for non-usr-merge systems
  MODULES_ROOT="/lib/modules"
fi
[[ -d "$MODULES_ROOT" ]] || die "Modules root not found: /usr/lib/modules or /lib/modules"
[[ -d "$DKMS_ROOT" ]] || die "DKMS root not found: $DKMS_ROOT"
[[ -d "$BOOT_ROOT" ]] || die "Boot root not found: $BOOT_ROOT"

ARCH="$(uname -m)"
RUNNING_KVER="$(uname -r)"

# kernel tree heuristic: avoid catching junk like "updates"
is_kernel_tree_dir() {
  local d="$1"
  [[ -f "$d/modules.dep" || -d "$d/kernel" || -f "$d/vmlinuz" ]]
}

# ---------- build installed kernels set ----------
declare -A INSTALLED=()

# 1) authoritative: /boot/vmlinuz-*
shopt -s nullglob
for f in "$BOOT_ROOT"/vmlinuz-*; do
  [[ -e "$f" ]] || continue
  bn="${f##*/}"
  kver="${bn#vmlinuz-}"
  [[ -n "$kver" ]] && INSTALLED["$kver"]=1
done
shopt -u nullglob

# 2) safety net: modules/<kver>/vmlinuz owned by rpm
#    (prevents accidental deletion if /boot list is unusual)
if command -v rpm >/dev/null 2>&1; then
  for d in "$MODULES_ROOT"/*; do
    [[ -d "$d" ]] || continue
    kver="${d##*/}"
    [[ -f "$d/vmlinuz" ]] || continue
    if rpm -qf "$d/vmlinuz" >/dev/null 2>&1; then
      INSTALLED["$kver"]=1
    fi
  done
fi

# 3) never touch running kernel
INSTALLED["$RUNNING_KVER"]=1

# ---------- collect candidate kernel versions from both locations ----------
declare -A CANDIDATE=()

# A) from /var/lib/dkms/<module>/<version>/<kver>
for mv in "$DKMS_ROOT"/*/*; do
  [[ -d "$mv" ]] || continue
  for kd in "$mv"/*; do
    [[ -d "$kd" ]] || continue
    kver="${kd##*/}"
    # skip non-kver nodes
    [[ "$kver" == "source" || "$kver" == "build" ]] && continue
    # dkms kernel build dirs normally contain arch subdir
    [[ -d "$kd/$ARCH" ]] || continue
    CANDIDATE["$kver"]=1
  done
done

# B) from /usr/lib/modules/<kver> (or /lib/modules/<kver>)
for d in "$MODULES_ROOT"/*; do
  [[ -d "$d" ]] || continue
  is_kernel_tree_dir "$d" || continue
  kver="${d##*/}"
  CANDIDATE["$kver"]=1
done

# ---------- purge orphans ----------
purge_kver_from_dkms() {
  local kver="$1"
  # remove exact depth-3 dkms kernel dirs: /var/lib/dkms/<mod>/<ver>/<kver>
  # (find keeps it strict and avoids touching unrelated trees)
  while IFS= read -r path; do
    log "ðŸ§¹ DKMS orphan dir: $path"
    run_rm_rf "$path"
  done < <(find "$DKMS_ROOT" -mindepth 3 -maxdepth 3 -type d -name "$kver" 2>/dev/null || true)
}

purge_kver_from_modules() {
  local kver="$1"
  local path="$MODULES_ROOT/$kver"
  if [[ -d "$path" ]]; then
    log "ðŸ§¹ Modules orphan dir: $path"
    run_rm_rf "$path"
  fi
}

# execute
for kver in "${!CANDIDATE[@]}"; do
  [[ -n "${INSTALLED[$kver]+x}" ]] && continue
  log "ðŸ§¹ Purging orphan kernel leftovers: $kver"
  purge_kver_from_dkms "$kver"
  purge_kver_from_modules "$kver"
done

exit 0
